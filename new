include irvine32.inc

.stack 4096

maxHand = 21
dealerStop = 17



getRandomNum MACRO location1
	mov eax, 13							; upper bound
	call RandomRange; lower bound
	add eax, 2; so its between 2 and 14
	mov location1, eax; move value into the array
	call writeInt
ENDM

printCard MACRO number
	mov eax, number						;move the number into eax
	cmp eax, 11
	jl noChange							;if under


	noChange:

	change: 


ENDM


.data
greeting byte "US dollars to Canadian by Ahmed Zaidan and Blaise", 13, 10, 0
myMessage2 BYTE "Enter the amount of canadian dollars you want to convert to US dollars: ", 32, 0
myMessage5 BYTE " candian dollars converted to US dollars is: ", 0
dist REAL8 ?
distConst REAL8 0.740926
kmPerMile REAL8 ?
betAmount DWORD ?
currentMoney DWORD ?
enterStartMoneyText BYTE "How much money are you gambling with today: ", 0
myArr DWORD 21 DUP(0)
dealerArr DWORD 21 DUP(0)

playAgain BYTE "Would you like to play a hand (Enter 1 for yes, Any other number is no): ", 0
inputRoundDollar BYTE "Enter bet: ", 0
betInvalid BYTE "Either bet is too above your budget or is negative", 0
roundSpent DWORD ?
playerCount DWORD 0
dealerCount DWORD 0

.code
main proc


	call randomize

	getUserInfo:
		push OFFSET currentMoney
		call userInput

	playGame:
		call game

	fpuExample:
		call floatingExample

exit
main endp

userInput PROC
	push EBP
	mov EBP, ESP
	mov esi, [ebp + 8]
	mov EDX, OFFSET enterStartMoneyText
	call writeString
	call readInt
	mov[esi], eax
	pop EBP
	ret
userInput ENDP

game PROC								; asks if you want to play : ask for money input,
	mov EDX, OFFSET playAgain
	call writeString
	call readInt
	call crlf
	cmp EAX, 1
	jne endOfProgram

	jmp getRoundMoney

	invalidInput :
		mov EDX, OFFSET betInvalid
		call writeString
		call crlf


	getRoundMoney :
		mov EDX, OFFSET inputRoundDollar
		call writeString
		call readInt
		call crlf

		cmp EAX, currentMoney
		jg invalidInput
		cmp EAX, 0
		jle invalidInput

		mov roundSpent, EAX

		call humanMove


	endOfProgram:
		ret

game ENDP



dealerFirst PROC

	ret
dealerFirst ENDP



humanMove PROC
	getRandom :
		mov ebx, playerCount				; move offset of the array into ebx
		getRandomNum myArr[ebx]

		add playerCount, 4					; move offset
		getRandomNum myArr[ebx]
	showUser:
		
	ret
humanMove ENDP




dealerMove PROC

	ret
dealerMove ENDP

compareHands PROC

	ret
compareHands ENDP



floatingExample PROC
	mov edx, offset greeting
	invoke WriteString				
	call Crlf; print newline
	finit;//iniit the fpu
	mov edx, offset myMessage2
	invoke WriteString; print message2
	call readFloat
	fst dist
	fstp st(0);//clear
	fld dist;//load the distance into the stack
	fld distConst;//load the distance constant for conversion
	fmul
	fst kmPerMile;//pop into this var
	fstp st(0);//clear
	call Crlf; print newline
	fld dist
	call writeFloat
	fstp st(0)
	mov edx, offset myMessage5
	invoke WriteString
	fld kmPerMile
	invoke WriteFloat
	fstp st(0)
floatingExample ENDP

end main
